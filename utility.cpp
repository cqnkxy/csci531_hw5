#include <iostream>
#include <string>
#include <cassert>
#include <vector>
#include "config.h"

using namespace std;

const bool DEBUG = true;
static const int Nk = aes_bits_config::Nk;
static const int Nr = aes_bits_config::Nr;
static const int Nb = aes_bits_config::Nb;
static const unsigned char _multiplicative_inverse[] = {
	0x00,0x01,0x8d,0xf6,0xcb,0x52,0x7b,0xd1,0xe8,0x4f,0x29,0xc0,0xb0,0xe1,0xe5,0xc7,
    0x74,0xb4,0xaa,0x4b,0x99,0x2b,0x60,0x5f,0x58,0x3f,0xfd,0xcc,0xff,0x40,0xee,0xb2,
    0x3a,0x6e,0x5a,0xf1,0x55,0x4d,0xa8,0xc9,0xc1,0x0a,0x98,0x15,0x30,0x44,0xa2,0xc2,
    0x2c,0x45,0x92,0x6c,0xf3,0x39,0x66,0x42,0xf2,0x35,0x20,0x6f,0x77,0xbb,0x59,0x19,
    0x1d,0xfe,0x37,0x67,0x2d,0x31,0xf5,0x69,0xa7,0x64,0xab,0x13,0x54,0x25,0xe9,0x09,
    0xed,0x5c,0x05,0xca,0x4c,0x24,0x87,0xbf,0x18,0x3e,0x22,0xf0,0x51,0xec,0x61,0x17,
    0x16,0x5e,0xaf,0xd3,0x49,0xa6,0x36,0x43,0xf4,0x47,0x91,0xdf,0x33,0x93,0x21,0x3b,
    0x79,0xb7,0x97,0x85,0x10,0xb5,0xba,0x3c,0xb6,0x70,0xd0,0x06,0xa1,0xfa,0x81,0x82,
    0x83,0x7e,0x7f,0x80,0x96,0x73,0xbe,0x56,0x9b,0x9e,0x95,0xd9,0xf7,0x02,0xb9,0xa4,
    0xde,0x6a,0x32,0x6d,0xd8,0x8a,0x84,0x72,0x2a,0x14,0x9f,0x88,0xf9,0xdc,0x89,0x9a,
    0xfb,0x7c,0x2e,0xc3,0x8f,0xb8,0x65,0x48,0x26,0xc8,0x12,0x4a,0xce,0xe7,0xd2,0x62,
    0x0c,0xe0,0x1f,0xef,0x11,0x75,0x78,0x71,0xa5,0x8e,0x76,0x3d,0xbd,0xbc,0x86,0x57,
    0x0b,0x28,0x2f,0xa3,0xda,0xd4,0xe4,0x0f,0xa9,0x27,0x53,0x04,0x1b,0xfc,0xac,0xe6,
    0x7a,0x07,0xae,0x63,0xc5,0xdb,0xe2,0xea,0x94,0x8b,0xc4,0xd5,0x9d,0xf8,0x90,0x6b,
    0xb1,0x0d,0xd6,0xeb,0xc6,0x0e,0xcf,0xad,0x08,0x4e,0xd7,0xe3,0x5d,0x50,0x1e,0xb3,
    0x5b,0x23,0x38,0x34,0x68,0x46,0x03,0x8c,0xdd,0x9c,0x7d,0xa0,0xcd,0x1a,0x41,0x1c
};

void fatal(const char *fmt, ...)
{
	va_list args;
	va_start(args, fmt);
	vfprintf(stderr, fmt, args);
	va_end(args);
	exit(1);
}

void dprint(const char *fmt, ...)
{
	if (DEBUG) {
		va_list args;
		va_start(args, fmt);
		vprintf(fmt, args);
		va_end(args);
	}
}

// the hex is supposed to be in range 00~ff
unsigned hex_to_dec(const string &hex)
{
	unsigned res = 0;
	for (size_t i = 0; i < hex.size(); i++) {
		char ch = tolower(hex[i]);
		if (!('0' <= ch && ch <= 'f')){
			fatal("%s Must be of all hex digits!\n", hex.c_str());
		}
		res = (res << 4) + ('0' <= ch && ch <= '9' ? ch - '0' : ch - 'a' + 10);
	}
	return res;
}

unsigned char xtimes(unsigned char b)
{
	if (b >> 7) {
		return (b << 1) ^ 0x1B;
	}
	return b << 1;
}

// Output: p(x) = a(x) • b(x)
// 1) setp←{01},A←a,v[0]←A
// 2) if b0 = 1 then set p ← a
// 3) forifrom1to7do:
// 3.1) v[i] ← xtimes(A), A ← v[i]
// 3.2) if bi = 1 then set p ← A ⊕ p
// 4) return (p)
unsigned char big_dot(unsigned char a, unsigned char b)
{
 	unsigned char p = (b & 0x1) ? a : 0, v = a;
	for (int i = 1; i <= 7; ++i) {
		v = xtimes(v);
		if ((b >> i) & 0x1) {
			p ^= v;
		}
	}
	return p;
}

void modular_product(
	const vector<unsigned char> &a,
	const vector<unsigned char> &b,
	vector<unsigned char> &res
){
	assert(a.size() == 4 && b.size() == 4);
	res.resize(4);
	res[3] = big_dot(a[3], b[3]) ^ big_dot(a[0], b[2]) ^ big_dot(a[1], b[1]) ^ big_dot(a[2], b[0]);
	res[2] = big_dot(a[2], b[3]) ^ big_dot(a[3], b[2]) ^ big_dot(a[0], b[1]) ^ big_dot(a[1], b[0]);
	res[1] = big_dot(a[1], b[3]) ^ big_dot(a[2], b[2]) ^ big_dot(a[3], b[1]) ^ big_dot(a[0], b[0]);
	res[0] = big_dot(a[0], b[3]) ^ big_dot(a[1], b[2]) ^ big_dot(a[2], b[1]) ^ big_dot(a[3], b[0]);
}

void word_xor(
	const vector<unsigned char> &self,
	const vector<unsigned char> &other,
	vector<unsigned char> &res
){
	assert(self.size() == other.size());
	res.resize(self.size());
	for (int i = 0; i < (int)self.size(); ++i) {
		res[i] = self[i] ^ other[i];
	}
}

string vec_to_str(const vector<unsigned char> &vec)
{
	string res;
	char buf[3];
	for (size_t i = 0; i < vec.size(); ++i) {
		sprintf(buf, "%02x", vec[i]);
		res += buf;
	}
	return res;
}

string vecs_to_str(const vector<vector<unsigned char> >&vecs)
{
	string res;
	char buf[3];
	for (int c = 0; c < Nb; ++c) {
		for (int r = 0; r < 4; ++r) {
			sprintf(buf, "%02x", vecs[r][c]);
			res += buf;
		}
	}
	return res;
}

string vecs_to_str(
	const vector<vector<unsigned char> >::iterator &start,
	const vector<vector<unsigned char> >::iterator &end
){
	string res;
	for (vector<vector<unsigned char> >::iterator itr = start;
			itr < end;
			++itr) {
		res += vec_to_str(*itr);
	}
	return res;
}

void left_circular_shift(vector<unsigned char> &vec, int pos)
{
	pos %= vec.size();
	for (int i = 0; i < pos; ++i) {
		vec.push_back(vec[i]);
	}
	vec.erase(vec.begin(), vec.begin()+pos);
}

unsigned char multiplicative_inverse(unsigned char x)
{
	return _multiplicative_inverse[x];
}
